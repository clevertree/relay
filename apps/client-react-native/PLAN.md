Relay Client (React Native) – Implementation Plan (Mobile + Desktop)

Purpose
- Implement the Relay client UI using React Native for a single JavaScript/TypeScript codebase targeting mobile (Android/iOS) and optionally desktop (Windows/macOS).
- Reuse existing core logic from `crates/relay-client-core` via Rust <-> Native bridges exposed to React Native as Native Modules/TurboModules to keep behavior consistent across platforms.
- Provide UX features adapted to React Native components and libraries.

Target platforms and phasing
- Phase 1 (Mobile-first): Android as the initial bring-up platform; then iOS.
- Phase 2 (Desktop, optional): macOS and Windows via `react-native-macos` and `react-native-windows` (Linux desktop deferred; consider Electron/Tauri separately if needed).

Environment
- Node.js LTS (>= 20), pnpm or yarn (project root uses pnpm; prefer pnpm).
- React Native >= 0.76 with Hermes engine enabled.
- TypeScript >= 5.
- Rust stable via rustup for building the shared Rust core.
- FFI bridge: two viable options:
  - Option A (initial, simpler): Classic Native Modules (Kotlin/Swift/Obj‑C) that call a Rust cdylib via C ABI (generated with `cbindgen`). Streams/events surfaced via RN `NativeEventEmitter`.
  - Option B (advanced, later): TurboModules + JSI C++ shim calling into Rust (for lower overhead and synchronous calls where safe). Start with A; iterate to B if needed.
- System deps per platform:
  - Android: Android SDK/NDK (r26+), JDK 17, Gradle (via RN), Rust targets `aarch64-linux-android`, `armv7-linux-androideabi`, `x86_64-linux-android` via `cargo-ndk`.
  - iOS: Xcode 15+, CocoaPods, Rust `aarch64-apple-ios` (and `x86_64-apple-ios` for simulator).
  - macOS (optional): `react-native-macos` toolchain; Rust `aarch64-apple-darwin`.
  - Windows (optional): Visual Studio Build Tools (MSVC), `react-native-windows`, Rust `x86_64-pc-windows-msvc`.
- Environment variables: `RELAY_MASTER_PEER_LIST` (semicolon-separated), `RUST_LOG=info` during development.

Repository structure
- crates/relay-client-core (existing Rust core logic)
  - `config.rs`: env/args
  - `peers.rs`: peer probing (HTTPS/Git/IPFS + last update)
  - `remotes.rs`: OPTIONS/GET/QUERY helpers
  - `plugins.rs`: plugin registry and descriptors
  - `scripts.rs`: JS engine abstraction
  - `md.rs`: markdown -> intermediate UI tree
- apps/client-react-native (new React Native app)
  - `package.json`: RN deps, scripts, workspace integration
  - `android/`, `ios/` (generated by RN CLI; plus optional `macos/`, `windows/` later)
  - `src/`
    - `App.tsx`: app bootstrap, navigation container, global state providers
    - `state/`: Zustand/Recoil/Redux stores for peers, tabs, plugins (choose one; default to Zustand for simplicity)
    - `components/`
      - `PeersView.tsx`: Peers health list/grid (auto-refresh)
      - `RepoTab.tsx`: Repo Browser per-peer tab shell (closable)
      - `MarkdownView.tsx`: render core `md` tree into RN components
      - `ScriptsConsole.tsx`: per-tab script console
      - `plugins/`
        - `DefaultNative.tsx`: Native Repo Browser (Visit/Search, GET/QUERY)
        - `WebViewPlugin.tsx`: Built-in WebView plugin + restricted bridge
        - `DeclarativeNative.tsx`: Declarative v1 native renderer
    - `native/` (bridge surface)
      - `RelayCoreModule.ts` (TypeScript typings for Native Module/TurboModule)
  - `rust/` (cdylib wrapper crate around relay-client-core)
    - `Cargo.toml`: cdylib for mobile/desktop targets, depends on `relay-client-core`
    - `src/lib.rs`: C ABI exported functions for peers/remotes/md/scripts
    - `include/relay_core.h`: generated by `cbindgen` for iOS/macOS C/Swift interop
  - `android/src/main/java/.../RelayCoreModule.kt`: RN Native Module calling Rust via JNI
  - `ios/RelayCoreModule.mm|swift`: RN Native Module calling Rust via C/Swift bridge

Bridging strategy (Rust core <-> React Native)
- Wrap select APIs from `relay-client-core` as a C ABI and call from platform code:
  - Peers: start/stop background probe, subscribe to updates (events emitted to JS via `NativeEventEmitter` or TurboModule callbacks).
  - Remotes: `options`, `get`, `query` with cancellation and timeouts.
  - Plugins model: list discovered plugins and descriptors.
  - Scripts: sandboxed JS evaluate with fetch limited to selected peer.
  - MD: parse markdown to an intermediate tree transferable to JS (serialize via JSON using `serde_json` or MessagePack; start with JSON strings).
- Build cdylib per platform. Android via `cargo-ndk` producing `.so` placed under `android/src/main/jniLibs/{abi}`. iOS/macOS produce `.a`/`.dylib` linked via Podspec or Xcode build phase.

Requirements mapping (to React Native)
1. Peer health view
   - Probe endpoints: HTTPS 443 (TCP + HEAD / latency median of 3), Git 9418 (TCP), SSH 22 (optional), IPFS API 5001 (POST /api/v0/version latency median), IPFS Gateway 8080 (HEAD /ipfs/), IPFS Swarm 4001 (TCP).
   - Fetch last update via `OPTIONS /` and take max timestamp from branchHeads when available.
   - UI: Use `FlatList`/`SectionList` with status chips; responsive two-column layout on tablets; auto-refresh ~10s; manual refresh button.

2. Repo Browser tabs
   - Tap on a peer opens a closable tab bound to `https://{host}`.
   - On tab mount, call `OPTIONS` via Rust core and parse branches, repos, branchHeads, and embedded `relay.yaml` (interface.<os>.*) for plugin discovery.
   - UI: React Navigation with a custom tabs stack; maintain per (peer, repo) state. On larger screens, consider `react-native-tab-view`.

3. Script runtime
   - JS engine inside Rust (QuickJS/Boa) sandboxed; expose only `fetch` (peer-bound) and timers. No filesystem/process.
   - UI: simple console area with input and output, per tab.

4. Default Repo Browser plugin (native)
   - Top bar path input (select-all on focus). Action button disabled until changed.
   - Visit (GET) when input looks like a path/URL; if directory, imply `index.md`.
   - Search (QUERY) otherwise: results list/grid with View action to navigate to `meta_dir/index.md`.
   - UI: `TextInput` + `Button`; results via `FlatList` with responsive cards.

5. Results grid
   - Columns inferred from returned fields; View button per row.
   - Support virtualization for large result sets (`FlatList` windowing) and pagination.

6. Markdown renderer
   - Option A: Convert Rust `md` intermediate tree to JSON and render with custom RN components.
   - Option B: Use `react-native-markdown-display` or `react-native-render-html` for standard markdown + custom renderers.
   - Support limited inline HTML; register custom tags such as `<video url="..."/>` → render with `react-native-video` or WebView fallback.
   - Directory path implies `index.md`.

7. Docs
   - Document plugin discovery and OS-specific loading; default to WebView when no OS-specific plugin is provided.
   - Document Rust FFI build for each platform (targets, NDK, signing where applicable) and how the RN Native Module links the library.

8. Build & packaging
   - Android: APK/AAB via Gradle; integrate Rust build as a Gradle task dependency (per ABI).
   - iOS: IPA/TestFlight via Xcode; integrate Rust build via a CocoaPods script phase or Xcode build phase.
   - Desktop (optional): macOS app via `react-native-macos`; Windows app via `react-native-windows`. Linux deferred.
   - CI: matrix builds using GitHub Actions; cache Rust + Android/Pods; run TypeScript checks and ESLint.

9. Archive old client docs
   - Migrate references from Flutter client plan; keep Flutter doc archived for historical context.

Milestones and acceptance criteria
- M1 (Android bring-up): Android app launches; Peers list shows HTTPS/Git/IPFS status and median latencies; auto-refresh ~10s; tapping opens a tab shell.
- M2: Plugin discovery and switcher (priority: RepoProvided -> Native -> WebView) with per-session persistence per (peer, repo).
- M3: Repo WebView plugin loads with restricted bridge exposing `relay.fetch/state/postMessage` only.
- M4: Declarative native plugin v1: manifest loads; markdown and grid render; row View navigates to `index.md`.
- M5: Default native Repo Browser: Visit/Search, GET/QUERY, results grid with View.
- M6: Markdown renderer supports custom tags such as `<video url="..."/>`.
- M7: Packaging and CI for Android; docs updated; legacy client docs archived.
- M8 (iOS bring-up): iOS simulator runs peers view; basic parity with Android.
- M9 (Optional Desktop): macOS build runs peers view; Windows build basic parity.

Task checklist
- T0: Initialize `apps/client-react-native` with RN CLI (no Expo); add TypeScript; wire workspace (pnpm) scripts.
- T1: Create Rust cdylib wrapper around `relay-client-core`; expose C ABI; set up `cbindgen` and Android/iOS build scripts.
- T2: Android JNI + RN Native Module scaffold; expose peers probing start/stop and event stream; render Peers list with auto/manual refresh.
- T3: Implement tab shell and `OPTIONS` info sidebar per tab; persist selection state.
- T4: Plugin registry and toolbar switcher (RepoProvided, BuiltInDefault, BuiltInWebView) with correct priority.
- T5: WebView plugin and restricted JS bridge implementation (`react-native-webview` with `injectedJavaScript` and message channel).
- T6: Declarative plugin loader (`GET plugin.manifest.json`) and native renderer for markdown/grid/detail-json/action; integrity by hash and caching via ETag/Last-Modified.
- T7: Default native Repo Browser (Visit/Search, GET/QUERY, results grid with View); path bar UX polish.
- T8: Markdown renderer with custom tags and asset resolution; choose Option A or B and implement custom renderers.
- T9: Script runtime UI (console) delegating to Rust JS engine; enforce timeouts and size caps.
- T10: Packaging and CI for Android; then extend to iOS.
- T11: iOS Native Module (Swift/Obj‑C) and basic QA on simulator/device.
- T12: Docs update; archive legacy client docs.

Dependencies (React Native)
- State management: `zustand` (default) or `redux`/`@reduxjs/toolkit`.
- Async/data: `@tanstack/react-query` (optional) to orchestrate calls around Native Module.
- Navigation/UI: `@react-navigation/native`, `@react-navigation/material-top-tabs` or `react-native-tab-view`, `react-native-paper` (optional) or custom components.
- WebView: `react-native-webview`.
- Markdown: `react-native-markdown-display` or `react-native-render-html`.
- Video/media: `react-native-video`.
- Serialization: use JSON via `serde_json` from Rust; parse in JS; consider `msgpackr` later for performance.
- Native bridge helpers: none mandatory; we maintain platform modules; consider `react-native-builder-bob` for packaging if extracting to a library.

FFI build targets (Rust)
- Android: `aarch64-linux-android`, `armv7-linux-androideabi`, `x86_64-linux-android`.
- iOS: `aarch64-apple-ios` (and simulator as needed).
- macOS (optional): `aarch64-apple-darwin` (and optionally `x86_64-apple-darwin`).
- Windows (optional): `x86_64-pc-windows-msvc`.

Security and sandboxing
- JS engine embedded in Rust remains sandboxed (no fs/process). Expose only peer-scoped fetch and timers via the bridge.
- WebView JS <-> RN bridge limits to `relay.fetch`, `relay.state` (read-only), `postMessage`. Validate origins per selected peer and sanitize all messages.

Performance & UX notes
- Keep heavy work in Rust. Minimize JS <-> Native bridge crossings by batching and streaming.
- Debounce peer probes and UI updates; batch diff updates from event streams.
- Use `FlatList` virtualization for large lists; lazy-load images/assets referenced in markdown.
- Consider migrating to TurboModules/JSI for hot paths once surface stabilizes.

Open items
- Decide bridge approach long-term (stay with Native Modules vs migrate to TurboModules/JSI) after initial Linux/Android prototypes.
- Decide state management (Zustand vs Redux) and navigation pattern for tabs on mobile.
- Styling preferences for Peers list and tab chrome.
- Any authentication headers required for OPTIONS/GET/QUERY.
- Decide Markdown renderer approach (Rust tree vs RN markdown lib) based on feature parity needs.

Definition of done for first UI test (Android)
- Android app launches on emulator/device.
- Peers view shows statuses and latencies and auto-refreshes.
- Tapping a peer opens a closable tab with `OPTIONS` info (branches, repos, branchHeads summary).
- Plugin selector lists Repo (if discovered), Default (native), and WebView; switching updates tab state.

Appendix: Developer quick start (Android)
1) Install Node, Android SDK/NDK, JDK 17, and Rust toolchains.
2) In `apps/client-react-native/rust`, run `cargo build` for host to validate core wrapper.
3) Configure Android Gradle task to invoke `cargo-ndk` for ABIs; generate headers with `cbindgen`.
4) `pnpm --filter client-react-native start` to run Metro; `pnpm --filter client-react-native android` to install and launch.

Last updated: 2025-12-01
