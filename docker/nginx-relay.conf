
# HTTP server: serve ACME challenges and redirect to HTTPS

# Upstream backend definition for relay server
upstream relay_upstream {
    server 127.0.0.1:8088;
}

# Map to detect GET/HEAD methods for fallback logic
map $request_method $is_get_or_head {
    default 0;
    GET 1;
    HEAD 1;
}

# CORS preflight detection: OPTIONS with Access-Control-Request-Method header
map $request_method $is_options {
    default 0;
    OPTIONS 1;
}

map $http_access_control_request_method $has_acrm_header {
    default 0;
    "" 0;
    ~.+ 1;
}

map "$is_options$has_acrm_header" $is_cors_preflight {
    default 0;
    "11" 1;
}

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;

    # Add permissive CORS headers even on HTTP. This covers edge cases where
    # the browser issues a preflight to port 80 (or encounters a redirect), so
    # the response still carries the CORS headers and avoids failures.
    add_header Access-Control-Allow-Origin "*" always;
    add_header Access-Control-Expose-Headers "Content-Length, Content-Range, ETag" always;

    # ACME HTTP-01 challenges
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/certbot;
        default_type "text/plain";
        allow all;
    }

    # Everything else -> HTTPS
    location / {
        # Handle CORS preflight on HTTP as well; respond 204 directly.
        if ($is_cors_preflight) {
            add_header Access-Control-Allow-Origin "*" always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers $http_access_control_request_headers;
            add_header Access-Control-Max-Age 86400;
            return 204;
        }
        return 301 https://$host$request_uri;
    }
}

# HTTPS server: proxy all requests to relay; on 404 for GET paths, serve client-web
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name _;

    # Stable symlinked cert path managed by entrypoint.sh
    ssl_certificate     /etc/letsencrypt/live/relay/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/relay/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;

    # CORS: allow all origins for all responses (no credentials)
    add_header Access-Control-Allow-Origin "*" always;
    # Expose common headers so browsers can read them
    add_header Access-Control-Expose-Headers "Content-Length, Content-Range, ETag" always;

    # Static web root for client-web artifacts
    root /srv/relay/www;
    index index.html;

    # ACME over HTTPS (some clients may follow redirect already)
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/certbot;
        default_type "text/plain";
        allow all;
    }

    # Proxy all requests to relay. If relay returns 404 on a GET/HEAD path, try static (client-web),
    # ultimately falling back to index.html (SPA). Non-GET/HEAD keep 404 from backend.
    location / {
        # Handle CORS preflight (OPTIONS + Access-Control-Request-Method)
        if ($is_cors_preflight) {
            add_header Access-Control-Allow-Origin "*" always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers $http_access_control_request_headers;
            add_header Access-Control-Max-Age 86400;
            return 204;
        }

        proxy_pass http://relay_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_buffering off;

        proxy_intercept_errors on;
        error_page 404 = @maybe_static_fallback;
    }

    # On 404 from backend: if method is GET/HEAD, try static; else return 404
    location @maybe_static_fallback {
        # If the original request was not GET or HEAD, preserve the backend's 404
        if ($is_get_or_head = 0) {
            return 404;
        }
        # For GET/HEAD, try to serve the static file or fall back to SPA index.html
        try_files $uri /index.html =404;
    }

    # Cache headers for static assets when served from /srv/relay/www
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        # Handle CORS preflight for static assets
        if ($is_cors_preflight) {
            add_header Access-Control-Allow-Origin "*" always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, PATCH, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers $http_access_control_request_headers;
            add_header Access-Control-Max-Age 86400;
            return 204;
        }

        try_files $uri =404;
        expires 1h;
        add_header Cache-Control "public, immutable";
        # Re-add CORS headers here because add_header in a location overrides server-level ones
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Expose-Headers "Content-Length, Content-Range, ETag" always;
    }

    # Named location: proxy to the relay upstream (used by try_files fallback)
    location @relay_upstream {
        proxy_pass http://relay_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 404 = @maybe_static_fallback;
    }
}
